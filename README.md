# 강현호 <h1>202130202

## 3월 15일 Java2 강의
깃 허브 주소를 복사하여 vscode에 붙여넣은뒤 깃 허브를 활용하는 방법에 대해 배웠다.
source control에 내용을 넣은 뒤 commit을 누른 뒤 업로드를 하면 깃 허브에 업로드가 된다.
java 개발 환경 구축
openJDK 설치, Eclips 설치, Eclips에 openJDK 연결
자바 프로젝트 생성

## 3월 22일 Java2 강의
자바 프로젝트, 클래스 생성 후 소스 편집, 컴파일 및 실행
자바 응용프로그램의 종류
- 데스크톱 응용프로그램
- 자바 서블릿 응용프로그램
- 모바일 응용프로그램

Java 특징
플랫폼 독립성, 객체 지향, 클래스로 캡슐화, 소스와 클래스파일, 실행 코드 배포, 패키지, 멀티스레드, 가비지 컬렉션,
프로그램 작성이 쉽다, 실행 속도를 개선하기 위해 JIT 컴파일러가 사용된다.

자바 프로그램의 구조
- 클래스 만들기
- 주석문
- main() 메소드
- 메소드, 메소드 호출
- 변수 선언
- 문장
- 화면 출력

식별자: 클래스, 변수, 상수, 메소드에 붙이는 이름(identifier)
식별자 이름 규칙에서 식별자를 만들 때 규칙을 준수 해야 함.
1. 식별자로 한글을 사용하면 안됨.
2. 길이 제한이 없음.
3. 대소문자 구별.

## 3월 29일 java2 강의
타입 변환이란 변수나 상수 혹은 리터럴을 다른 타입을 변환하는것을 말한다.
- 자동타입 변환: 치환문이나 수식 내에서 타입이 일치하지 않을때 컴파일러는 작은 타입을 큰 타입으로 자동변환
- 강제타입 변환(캐스팅) : 큰 타입을 작은 타입으로 변환해야 할때 자동 변환 대신 컴파일 오류 발생 손실이 발생한다는 사실을 알고 변환한다면 강제로()안에 타입을 지정

자바의 키 입력
- System.in
표준 입력 스트림 객체로, 키 값을 바이트 정보로 바꾸어 제공하는 저수준 스트림 객체

Scanner을 이용한 키 입력 
- scanner 객체는 다음과 같이 생성한다.
"scanner scanner - new scanner(system.in);"
- Scanner을 사용하기 위해서는 프로그램의 맨 앞줄에 "import" 문이 필요하다.
"import java.util.Scanner;"
import문은 scanner 클래스의 경로명이 java.utill.scanner임을 알려준다

예제 2-5 연습

식과 연산자
- 주어진 식을 계산하여 결과를 얻어내는 과정을 연산이라고 한다

산술연산
- 수직 계산에 사용하는 산술 연산자는 더하기,빼기, 곱하기, 나누기, 나머지(%)의 5갸더 /는 몫을 구하여, %는 나머지를 구한다

예제 2-6 연습

증강연산
-  ++,-- 피연산자의 앞 또는 뒤에 붙어 값을 1 증가시키거나 1 감소시킨다.
a++ a를 1 증가하고 증가전의 값 변환
++a a를 1증가하고 증가된 값 변환
a-- a를 1 가모하고 감소 전의 값 변환
--a a를 1 감소하고 감소된 값 변환

대입 연산 
- 연산자의 오른쪽 식의 결과를 왼쪽에 있는 변수에 대입

비교연산, 논리 연산
- 비교연산자는 두 개의 피연산자를 비교하여 true 또는 false의 논리 결과를 내는 연산자
- 논리 연산자는 논리 값을 대상으로 AND,OR,XOR,NOT의 논리 연산을 하여 논리 값을 내는 연산자

조건문
- 단순 IF문 조건식은 비교 연산이나 논리 연산의 혼합된 식으로 구성되며 결과는 불린 값이다.
- 조건식이 참이면 if 내부의 실행 문장이 실행되며 거짓이면 if문을 벗어난다
- 다중 if-else 문은 if의 '조건식'이 참인 경우와 거짓인 경우에 실행할 문장을 각각 지시한다

## 4월 05일 java2 강의
2차원 배열
- 2차원 배열의 선언과 생성
1차원 배열과 마찬가지로 2차원 배열에서도 레퍼런스 변수 선언 후 배열을 생성하며, 2차원 배열의 레퍼런스 변수를 선언
int inArray[][]; 또는 int [][] intArray; // 2차원 배열의 레퍼런스 변수 선언
intArray = new int[2][5]; // 2행 5열(2*5)의 2차원 배열 생성

2차원 배열의 초기화
- 2차원 배열을 선언할 때 각 원소를 초기화 할 수 있다. 자동으로 초기화된 배열이 생성된다.
int inArray[][] = { {0,1,2}, {3,4,5}, {6,7,8} }; // 3*3 배열 생성
char charArray[][] = { {'a','b','c'}, {'d','e','f'} }; // 2*3 배열 생성
double doubleArray[][] = { {0.01,0.02}, {0.03,0.04} }; // 2*2 배열 생성

자바의 예외 처리
예외한 실행 중 오동작이나 결과에 악영향을 미치는 예상치 못한 상황 발생을 예외라고 한다.
- 예외 발생 사례
정수를 0으로 나누는 경우
배열의 크기보다 큰 인덱스로 배열의 원소를 접근하는 경우
정수를 읽는 코드가 실행되고 있을 때 사용자가 문자를 입력한 경우

자바의 예외 처리,try-catch-finally 문
예외 처리란 발생한 예외에 대해 개발자가 작성한 프로그램 내에서 대응하는 것을 말한다. 자바는 예외 처리시 try,catch,finally문을 사용
try {
    예외가 발생할 가능성이 있는 실행문(try 블록)
}
catch (처리할 예외 타입 선언){
    예외 처리문(catch 블록)
}
finally {
    예외 발생 여부와 상관없이 무조건 실행되는 문장(finally 블록)
}

예외가 발생할 가능성이 있는 실행문들을 try{} 블록으로 묶고, 예외 처리 코드는 catch{} 블록에 작성한다.
catch() 문의 () 안에는 처리하고자 하는 예외의 타입을 선언한다. catch {} 블록은 예외마다 하나씩 작성되어야 한다.
finally {}는 선택적 구문으로서 생략해도 상관없으며 실제 많은 경우 생략된다.
finally 블록이 존재하는 경우, try 블록 실행 후 finally 블록이 순차적으로 실행되며, try 블록이 실행되는 도중 예외가 발생하였다면 catch 블록 실행 후 finally 블록을 실행한다. 그리고 finally 블록 아래의 코드를 계속 실행한다.

객체 지향 언어의 목적
- 소프트웨어의 생산성 향상
1. 컴퓨터 산업 발전에 따라 소프트웨어의 생명 주기(life cycle) 단축
2. 객체 지향 언어

- 실세계에 대한 쉬운 모델링
1. 초기 프로그래밍
2. 현대 프로그래밍
3. 객체 지향 언어
   
## 4월 12일 java2 강의
static 멤버 
- 클래스의 멤버들 중 다음과 같이 static 지시어로 선언된 멤버를 
static 멤버라고 부른다
- static으로 선언된 멤버는 non-static 멤버와 매우 다른 특성을 가진다
- static 멤버는 클래스당 하나만 생성되는 멤버로서, 동일한 클래스의 
모든 객체들이 공유하므로 클래스 멤버라고 부른다
- non-static 멤버는 객체가 생길때 함께 생성되고 객체가 사라지면 함께 사라진다 그러나 static 멤버는 프로그램을 시작할 때나 클래스 로딩 시에 생성된다
- 객체를 생성하기 전에도 static 멤버는 사용
-  생성된 객체가 소멸된 후에도 static 멤버는 여전히 살아 공간을 차지하고 있으며 프로그램이 종료할 때 함께 소멸

static 멤버 사용
non-static 멤버가 객체 이름으로만 활용 할 수 있는 것과는 달리
static멤버는 객체 이름이나 클래스 이름으로 모두 활용 가능하다.
   staticsample.m =3; // 클래스 이름으로 static필드 접근
   staticsample.f(); // 클래스 이름으로 static 메소드 호출

static 메소드의 제약 조건
static 메소드는 두 개의 제약 사항을 가진다

- static 메소드는 오직 static 멤버만 접근 할 수 있다.
static 메소드는 객체가 생성디지 않은 상황에서도 사용이 가능하므로
객체에 속한 인스턴스 메소드, 인스턴스 변수 등을 사용할 수 없고
static 멤버들만 사용 가능하다.
인스턴스 메소드는 static멤버들을 사용할 수 있다.

- static 메소드에서는 this를 사용할 수없다
static메소드는 객체 없이도 존재하기 때문에, static 메소드에서 
this를 사용할 수 없다.

final 클래스
final 클래스 이름 앞에  사용되면 클래스를 상속받을 수 없음을 지정한다.

final 메소드
메소드 앞에 final이 붙으면 이 메소드는 더 이상 오버라이딩 할 수 없음을 지저한다
자식 클래스가 부모 클래스의 특정 메소드를 오버라이딩 하지 못하게 하고 
무조건 상속받아 사용하도록 하고자 한다면 final로 지정하면 된다.

final 필드 
자바에서 final로 필드를 선언하면 필드는 상수가 된다.
상수 필드는 한번 초기화 되면 값을 변경할수없다.
final 키워드를 public static와 함께 선언하면 프로그램 전체에서 공유할 수 있는
상수가된다

자바 상속의 특징
- 클래스 다중 상속(multiple ingeritance) 불허
C++는 다중 상속 가능(C++는 다중 상속으로 멤버가 중복 생성되는 문제 있음)
자바는 인터페이스(interface)의 다중 상속 허용
- 모든 자바 클래스는 묵시적으로 Object클래스 상속 받음
java.iang.Object는 클래스는 모든 클래스의 슈퍼 클래스

슈퍼 클래스의 멤버에 대한 서브 클래스의 접근
- 슈퍼 클래스의 private 멤버
서브 클래스에서 접근할 수 없음
-슈퍼 클래스의 디폴트 멤버
서브 클래스가 동일한 패키지에 있을 때, 접근 가능
- 서브 클래스의 public 멤버
서브 클래스는 항상 접근 가능
- 서브 클래스의  protected 멤버
같은 패키지 내의 모든 클래스 접근 허용
패키지 여부와 상관없이 서브 클래스는 접근 가능

protected 멤버
- proctected 멤버에 대한 접근
같은 패키지의 모든 클래스에게 허용
상속되는 서브 클래스(같은 패키지든 다른 패키지든 상관 없음)에게 허용

서브 클래스/슈퍼 클래스의 생성사 호줄과 실행
- 서브 클래스의 객체가 생성될 때
슈퍼 클래스 생성자와 서브 클래스 생성자 모두 실행
호출 순서
- 서브 클래스의 생성자 먼저 호출
-서브 클래스의 생성자는 실행 전 슈퍼 클래스 생성자 호출
실행 순서
- 슈퍼 클래스의 생성자가 먼저 실행된 후 서브 클래스의 생성자 실행

서브 클래스와 슈퍼 클래스의 생성자 선택
- 슈퍼 클래스와 서브 클래스
각각 여러 개의 생성자 작성 가능
- 서브 클래스의 객체가 생성될 때
슈퍼 클래스 생성자 1개와 서브 클래스 생성자 1개가 실행
- 서브 클래스의 생성자와 슈퍼 클래스의 생성자가 결정되는 방식
1. 개발자의 명시적 선택
 - 서브 클래스 개발자가 슈퍼 클래스의 생성자 명시적 선택
 - super() 키워드를 이용하여 선택
2. 컴파일러가 기본생성자 선택
 - 서브 클래스 개발자가 슈퍼 클래스의 생성자를 선택하지 않는 경우
 - 컴파일러가 자동으로 슈퍼 클래스의 기본 생성자 선택

 상속의 장점
 - 클래스 사이의 멤버 중복 선언 불필요 - 클래스의 간결화
 - 클래스들의 계층적 분류로 클래스 관리 용어
 - 클래스 재사용과 확장을 통한 소프트웨어의 생산성 향상

 클래스 상속과 객체
 - 상속 선언
 extends 키워드로 선언 (부모 클래스를 물려받아 확장한다는 의미)
 부모 클래스 -> 슈퍼 클래스(super class)
 자식 클래스 -> 서브 클래스(sub class)

 서브 클래스 객체의 모양
 - 슈퍼 클래스 객체와 서브 클래스의 객체는 별개
 - 서브 클래스 개게는 슈퍼 클래스 멤버 포함

 서브 클래스 객체 생성
 Point 클래스의 객체 p와 Colorpoint 클래스의 객체 cp는 다음가 같이 생성한다
    Point p = new Point();
    ColorPoint cp = new ColorPoint(); // 서브 클래스 객체 생성
자바 상속의 특징
- 클래스 다중 상속(multiple ingeritance) 불허
C++는 다중 상속 가능(C++는 다중 상속으로 멤버가 중복 생성되는 문제 있음)
자바는 인터페이스(interface)의 다중 상속 허용
- 모든 자바 클래스는 묵시적으로 Object클래스 상속 받음
java.iang.Object는 클래스는 모든 클래스의 슈퍼 클래스

슈퍼 클래스의 멤버에 대한 서브 클래스의 접근
- 슈퍼 클래스의 private 멤버
서브 클래스에서 접근할 수 없음
-슈퍼 클래스의 디폴트 멤버
서브 클래스가 동일한 패키지에 있을 때, 접근 가능
- 서브 클래스의 public 멤버
서브 클래스는 항상 접근 가능
- 서브 클래스의  protected 멤버
같은 패키지 내의 모든 클래스 접근 허용
패키지 여부와 상관없이 서브 클래스는 접근 가능

protected 멤버
- proctected 멤버에 대한 접근
같은 패키지의 모든 클래스에게 허용
상속되는 서브 클래스(같은 패키지든 다른 패키지든 상관 없음)에게 허용

서브 클래스/슈퍼 클래스의 생성사 호줄과 실행
- 서브 클래스의 객체가 생성될 때
슈퍼 클래스 생성자와 서브 클래스 생성자 모두 실행
호출 순서
- 서브 클래스의 생성자 먼저 호출
-서브 클래스의 생성자는 실행 전 슈퍼 클래스 생성자 호출
실행 순서
- 슈퍼 클래스의 생성자가 먼저 실행된 후 서브 클래스의 생성자 실행

서브 클래스와 슈퍼 클래스의 생성자 선택
- 슈퍼 클래스와 서브 클래스
각각 여러 개의 생성자 작성 가능
- 서브 클래스의 객체가 생성될 때
슈퍼 클래스 생성자 1개와 서브 클래스 생성자 1개가 실행
- 서브 클래스의 생성자와 슈퍼 클래스의 생성자가 결정되는 방식
1. 개발자의 명시적 선택
 - 서브 클래스 개발자가 슈퍼 클래스의 생성자 명시적 선택
 - super() 키워드를 이용하여 선택
2. 컴파일러가 기본생성자 선택
 - 서브 클래스 개발자가 슈퍼 클래스의 생성자를 선택하지 않는 경우
 - 컴파일러가 자동으로 슈퍼 클래스의 기본 생성자 선택

 상속의 장점
 - 클래스 사이의 멤버 중복 선언 불필요 - 클래스의 간결화
 - 클래스들의 계층적 분류로 클래스 관리 용어
 - 클래스 재사용과 확장을 통한 소프트웨어의 생산성 향상

 클래스 상속과 객체
 - 상속 선언
 extends 키워드로 선언 (부모 클래스를 물려받아 확장한다는 의미)
 부모 클래스 -> 슈퍼 클래스(super class)
 자식 클래스 -> 서브 클래스(sub class)

 서브 클래스 객체의 모양
 - 슈퍼 클래스 객체와 서브 클래스의 객체는 별개
 - 서브 클래스 개게는 슈퍼 클래스 멤버 포함

 서브 클래스 객체 생성
 Point 클래스의 객체 p와 Colorpoint 클래스의 객체 cp는 다음가 같이 생성한다
    Point p = new Point();

## 5월 3일 java2 강의
컬렉션
- 요소 라고 불리는 가변 개수의 객체들의 저장소
- 고정 크기의 배열을 다루는 어려움 해소

## 컬렉션의 특징
1. 컬렉션은 제네릭(generics)기법으로 구현
- 컬렉션 클래스나 인터페이스의 이름에는 <E>,<K>,<V> 등이 항상 포함된다. 이들은 "타입 매개 변수" 라고 하며, 컬렉션 요소<element>를 '일반화'시킨 타입이다. 
그러므로 Vector<E>에서 E 대신 Integer나 String으로 구체적인 타입을 지정하여 사용한다
2. 컬렉션의 요소는 객체들만 가능하다.
- int,char,double 등의 기본 타입의 데이터는 기본적으로 컬렉션의 요소로 불가능하다.

## 제네릭의 기본 개념
- 제네릭은 메소드나 클래스 코드를 찍어내듯이 생산할 수 있도록 일반화(generic)시키는 도구이다.

## 제네릭 타입 매개 변수
- E : Element 를 의미하며 컬렉션에서 요소를 표시할 때 사용
- T : Type을 의미
- V : Value를 의미
- K : key를 의미

## 벡터 Vector<E>의 특징
- <E>에 사용할 요소의 특정 타입으로 구체화
- 배열을 가변 크기로 다룰 수 있게 하는 컨테이너
1. 배열의 길이 제한 극복
2. 요소의 개수가 넘치면 자동으로 길이 조절
- 요소 객체들을 삽입,삭제,검색하는 컨테이너
1. 삽입,삭제에 따라 자동으로 요소의 위치 조정
- Vector에 삽입 가능한 것
1. 객체,null
2. 기본 타입의 값은 Wrapper객체로 만들어 저장
- Vector에 객체 삽입
1. 벡터의 맨 뒤, 중간에 객체 삽입 가능
- Vector에서 객체 삭제
1. 임의의 위치에 있는 객체 삭제 가능

## ArrayList<E>
- 가변 크기 배열을 구현한 클래스
1. <E>에 요소로 사용할 특정 타입으로 구체화
- 벡터와 거의 동일
1. 요소 삽입, 삭제, 검색 등 벡터 기능과 거의 동일
2. 벡터와 달리 스레드 동기화 기능 없음

## 컬렉션의 순차 검색을 위한 Iterator
- Iterator<E> 인터페이스
    - 리스트 구조의 컬렉션에서 요소의 순차 검색을 위한 인터페이스
    - Vector<E>, ArrayList<E>, LinkedList<E>가 상속받는 인터페이스
- Iterator 객체 얻어내기
    - 컬렉션의 iterator() 메소드 호출
    - 해당 컬렉션을 순차 검색할 수 있는 Iterator 객체 리턴

## HashMap<K,V>
- 키(Key)와 값(Value)의 쌍으로 구성되는 요소를 다루는 컬렉션
    - K : 키로 사용할 요소의 타입
    - V : 값으로 사용할 요소의 타입
    - 키와 값이 한쌍으로 삽입
    - '값'을 검색하기 위해서는 반드시 '키' 이용    
- 삽입 및 검색이 빠른 특징
    - 요소 삽입 : put()메소드
    - 요소 검색 : get()메소드

 ## 자바의 GUI(Graphical User Interface) 
GUI 응용 프로그램
- GUI
    - 사용자가 편리하게 입출력 할 수 있도록 그래픽으로 화면을 구성하고, 마우스나 키보드로 입력 받을 수 있도록 지원하는 사용자 인터페이스
- 자바 언어에서 GUI 응용프로그램 작성
    - AWT와 Swing 패키지에 강력한 GUI 컴포넌트 제공
    - 쉬운 GUI 프로그래밍

AWT와 Swing 패키지
- AWT(Abstract Windowing Toolkit) 패키지
    - 자바가 처음 나왔을 때부터 배포된 GUI패키지, 최근에는 거의 사용하지 않음
    - AWT 컴포넌트는 중량 컴포넌트(heavy weight component)
- Swing 패키지
    - AWT 기술을 기반으로 작성된 자바 라이브러리
    - 모든 AWT 기능 + 추가된 풍부하고 화려한 고급 컴포넌트
    - AWT 컴포넌트를 모두 스윙으로 재작성. AWT 컴포넌트 이름 앞에 J를 덧붙임
    - 순수 자바 언어로 구현
    - 스윙 컴포넌트는 경량 컴포넌트(light weight component)
    - 현재 자바의 GUI로 사용됨 

## 컨테이너와 컴포넌트
컨테이너
- 다른 컴포넌트를 포함할 수 있는 GUI 컴포넌트
    - java.awt.Container를 상속받음
- 다른 컨테이너에 포함될 수 있음
    - AWT 컨테이너 : Panel,Frame,Applet,Dialog,Window
    - Swing 컨테이너 : JPanel,JFrame,JApplet,Jdialog,JWindow

컴포넌트
- 컨테이너에 포함되어야 화면에 출력될 수 있는 GUI 객체
- 다른 컴포넌트를 포함할 수 없는 순수 컴포넌트
- 모든 GUI 컴포넌트가 상속받는 클래스 : java.awt.Component
- 스윙 컴포넌트가 상속받는 클래스 : javax.swing.JComponent

최상위 컨테이너
- 다른 컨테이너에 포함되지 않고도 화면에 출력되며 독립적으로 존재 가능한 컨테이너
    - 스스로 화면에 자신을 출력하는 컨테이너 : JFrame,JDialog,JApplet

## 스윙 GUI 프로그램 만들기
- 스윙 GUI 프로그램을 만드는 과정
1. 스윙 프레임 만들기
2. main() 메소드 작성
3. 스윙 프레임에 스윙 컴포넌트 붙이기

- 스윙 프로그램 작성에 필요한 import문
    - import java.awt.*; //그래픽 처리를 위한 클래스들의 경로명
    - import java.awt.event.*; // AWT 이벤트 사용을 위한 경로명
    - import javax.swing.*; // 스윙 컴포넌트 클래스들의 경로명
    - import.javax.swing.event.*; // 스윙 이벤트를 위한 경로명

## 스윙 프레임
- 스윙 프레임 : 모든 스윙 컴포넌트를 담는 최상위 컨테이너
    - JFrame을 상속받아 구현
    - 컴포넌트들은 화면에 보이려면 스윙 프레임에 부착되어야함
- 스윙 프레임(JFrame) 기본 구성
    - 프레임 - 스윙 프로그램의 기본 틀
    - 메뉴바 - 메뉴들이 부착되는 공간
    - 컨텐트팬 - GUI 컴포넌트들이 부착되는 공간

## 프레임 만들기 ,JFrame 클래스 상속
- 스윙 프레임
    - JFrame 클래스를 상속받은 클래스 작성
    - 프레임의 크기 반드시 지정 : setSize() 호출
    - 프레임을 화면에 출력하는 코드 반드시 필요 : setVisible(true) 호출

## 스윙 응용프로그램에서 main()의 기능과 위치
- 스윙 응용프로그램에서 main()의 기능 최소화 바람자기
    - 스윙 응용프로그램이 실행되는 시작점으로서의 기능만
    - 스윙 프레임을 생성하는 정도의 코드로 최소화
public static void main(String [] args) {
    MyFrame frame = new MyFrame(); // 스윙 프레임 생성
}

## 프레임에 컴포넌트 붙이기
- 타이틀 달기
    - super() 나 setTitle() 이용
- 컨텐트팬에 컴포넌트 달기
- 컨텐트팬이란?
    - 스윙 컴포넌트들이 부착되는 공간
- 컨텐트팬 알아내기
    - 스윙 프레임에 붙은 디폴트 컨텐트팬 알아내기
- 컨텐트팬에 컴포넌트 붙이기
- 컨텐트팬 변경

- ## 이벤트 기반 프로그래밍
- 이벤트의 발생에 의해 프로그램 흐름이 결정되는 방식
    - 이벤트가 발생하면 이벤트를 처리하는 루틴(이벤트 리스너) 실행
    - 실행될 코드는 이벤트의 발생에 의해 전적으로 결정
- 반대되는 개념 : 배치 실행
    - 프로그램의 개발자가 프로그램의 흐름을 결정하는 방식
- 이벤트 종류
    - 사용자의 입력 : 마우스 드래그, 클릭, 키보드 누름 등
    - 센서로부터의 입력, 네트워크로부터의 송수신
    - 다른 응용프로그램이나 다른 스레드로부터의 메시지
- 이벤트 기반 응용 프로그램의 구조
    - 각 이벤트마다 처리하는 리스너 코드 보유
- GUI 응용프로그램은 이벤트 기반 프로그래밍으로 작성됨
    - GUI 라이브러리 종류
        - C++의 MFC, C# GUI, Visual Basic, X Window, Android 등
        - 자바의 AWT와 Swing
## 자바 스윙 프로그램에서 이벤트 처리 과정
 이벤트가 처리되는 과정
- 이벤트 발생
    - 예 : 마우스의 움직임 혹은 키보드 입력
- 이벤트 객체 생성
    - 현재 발생한 이벤트에 대한 정보를 가진 객체
- 응용프로그램에 작성된 이벤트 리스너 찾기
- 이벤트 리스너 실행
    - 리스너에 이벤트 객체 전달
    - 리스너 코드 실행
## 이벤트 객체
- 발생한 이벤트에 관한 정보를 가진 객체
- 이벤트 리스너에 전달됨
    - 이벤트 리스너 코드가 발생한 이벤트에 대한 상황을 파악할 수 있게 함
## 이벤트 객체가 포함하는 정보
- 이벤트 종류와 이벤트 소스
- 이벤트가 발생한 화면 좌표 및 컴포넌트 내 좌표
- 이벤트가 발생한 버튼이나 메뉴 아이템의 문자열
- 클릭된 마우스 버튼 번호 및 마우스의 클릭 횟수
- 키의 코드 값과 문자 값
- 체크박스, 라디오버튼 등과 같은 컴포넌트에 이벤트가 발생하였다면 체크 상태
## 이벤트 소스를 알아 내는 메소드
- Object getSource()
    - 발생한 이벤트의 소스 컴포넌트 리턴
    - Object 타입으로 리턴하므로 캐스팅하여 사용
    - 모든 이벤트 객체에 대해 적용
## 리스너 인터페이스
- 이벤트 리스너
    - 이벤트를 처리하는 자바 프로그램 코드, 클래스로 작성
- 자바는 다양한 리스너 인터페이스 제공
- 사용자의 이벤트 리스너 작성
    - 자바의 리스너 인터페이스를 상속받아 구현
    - 리스너 인터페이스의 모든 추상 메소드 구현
## 이벤트 리스너 작성 방법
- 3가지 방법
    - 독립 클래스로 작성
        - 이벤트 리스너를 완전한 클래스로 작성
        - 이벤트 리스너를 여러 곳에서 사용할 때 적합함.
    - 내부 클래스(inner class)로 작성
        - 클래스 안에 멤버처럼 클래스 작성
        - 이벤트 리스너를 특정 클래스에서만 사용할 때 적합
    - 익명 클래스(anonymous class)로 작성
        - 클래스의 이름 없이 간단히 리스너 작성
        - 클래스 조차 만들 필요 없이 리스너 코드가 간단한 경우에 적합
## 자바의 GUI 프로그래밍 방법
- GUI 프로그래밍 방법 2종류
    - 컴포넌트 기반 GUI 프로그래밍
    - 그래픽 기반 GUI 프로그래밍

## JComponent
- 스윙 컴포넌트는 모두 상속받는 슈퍼 클래스, 추상 클래스
- 스윙 컴포넌트들이 상속받는 공통 메소드와 상수 구현

## JLabel로 문자열과 이미지 출력
- JLabel의 용도
    - 문자열이나 이미지를 화면에 출력하기 위한 목적
- 문자열 레이블 생성
    - JLabel textLabel = new JLabel("사랑합니다");
- 이미지 레이블 생성
    - 이미지 파일로부터 이미지를 읽기 위해 imagelcon 클래스 사용
    - 다룰 수 있는 이미지 : png,gif,jpg
- 수평 정렬 값을 가진 레이블 컴포넌트 생성
    - lmagelcon image = new lmagelcon("images/sunset.jpg");
    - JLabel label = new JLabel("사랑합니다", image, SwingConstants.CENTER);

## JButton의 용도
- 버튼 모양의 컴포넌트. 사용자로부터 명령을 입력받기 위한 목적
- 버튼은 클릭될 때 Action 이벤트 발생

## 이미지 버튼 만들기
- 하나의 버튼에 3개의 이미지 등록
    - 마우스 조작에 따라 3개의 이미지 중 적절한 이미지 자동 출력
- 3개의 버튼 이미지
    - noremallcon
        - 버튼의 보통 상태(디폴트) 때 출력되는 이미지
        - 생성자에 이미지 아이콘 전달 혹은 JButton의 setIcon(normallcon);
    - rolloverlcon
        - 버튼에 마우스가 올라갈 때 출력되는 이미지
        - 이미지 설정 메소드:JButton의 setRolloverIcon(rolloverIcon);
    - pressedlcon
        - 버튼을 누른 상태 때 출력되는 이미지
        - 이미지 설정 메소드:JButton의 setPressedIcon(pressedIcon)

## 체크박스에 item 이벤트 처리
- item 이벤트
    - 체크 박스의 선택 상태에 변화가 생길 때 발생하는 이벤트
        - 사용자가 마우스나 키보드로 체크박스를 선택/해제할 때
        - 프로그램에서 체크박스를 선택/해제하여 체크 상태에 변화가 생길 때
    - 이벤트가 발생하면 itemEvent 객체 생성
    - itemListener 리스너를 이용하여 이벤트 처리

## 스윙 컴포넌트 그리기, paintComponent()
- 스윙의 페인팅 기본
    - 모든 컴포넌트는 자신의 모양을 스스로 그린다.
    - 컨테이너는 자신을 그린 후 그 위에 자식 컴포넌트들에게 그리기 지시
    - 모든 스윙 컴포넌트는 자신의 모양을 그리는 paintComponent() 메소드 보유
- public void paintComponent(Graphics g)
    - 스윙 컴포넌트가 자신의 모양을 그리는 메소드
    - JComponent의 메소드 : 모든 스윙 컴포넌트가 이 메소드를 오버라이딩함
    - 언제 호출되는가?
        - 컴포넌트가 그려져야 하는 시점마다 호출
        - 크기가 변경되거나, 위치가 변경되거나, 컴포넌트가 가려졌던 것이 사라지는 등
- 매개변수인 Graphics 객체
    - 그래픽 컨텍스트 : 컴포넌트 그리기에 필요한 도구를 제공하는 객체
    - 자바 플랫폼에 의해 공급
    - 색 지정, 도형 그리기, 클리핑, 이미지 그리기 등의 메소드 제공

## JPanel
- 비어 있는 컨테이너
- 개발자가 다양한 GUI를 창출할 수 있는 캔버스로 적합
- JPanel을 상속받아 개발자 임의의 모양을 가지는 패널로 많이 사용

## 그래픽 기반 GUI 프로그래밍
- 스윙 컴포넌트에 의존하지 않고 선, 원 이미지 등을 이용하여 직접 화면을 구성하는 방법
- 그래픽 기반 GUI 프로그래밍의 학습이 필요한 이유
    - 컴포넌트의 한계를 극복하고 차트, 게임 등 자유로운 콘텐츠 표현
    - 그래픽은 컴포넌트에 비해 화면 출력 속도가 빠름
    - 스윙 컴포넌트들로 모두 그래픽으로 작성되어 있어, 그래픽에 대한 학습은 자바 GUI의 바탕 기술을 이해하는데 도움
    - 그래픽을 이용하여 개발자 자신만의 컴포넌트 개발

## Graphics와 문자열 출력
- 기능
    - 색상 선택하기
    - 문자열 그리기
    - 도형 그리기
    - 도형 칠하기
    - 이미지 그리기
    - 클리핑

## 스윙에서 이미지를 그리는 2가지 방법
1. JLabel을 이용한 이미지 그리기
- 장점 : 이미지 그리기 간편 용이
- 단점 : 이미지의 원본 크기대로 그리므로 이미지 크기 조절 불가
2. Graphics의 drawimage()로 이미지 출력
- 장점 : 이미지 일부분 등 이미지의 원본 크기와 다르게 그리기 가능
- 단점 : 컴포넌트로 관리할 수 없음, 이미지의 위치나 크기 등을 적절히 조절하는 코딩 필요

## repaint()
- 모든 컴포넌트가 가지고 있는 메소드
- 자바 플랫폼에게 컴포넌트 그리기를 강제 지시하는 메소드
- repaint()를 호출하면, 자바 플랫폼이 컴포넌트의 paintComponent() 호출

- repaint()의 호출이 필요한 경우
    - 개발자가 컴포넌트를 다시 그리고자 하는 경우
- 부모 컴포넌트부터 다시 그리는것이 좋음
    - 컴포넌트 repaint()가 불려지면
        - 이 컴포넌트는 새로운 위치에 다시 그려지지만 이전의 위치에 있던 자신의 모양이 남아 이음
    - 부모 컴포넌트 repaint()를 호출하면
        - 부모 컨테이너의 모든 내용을 지우고 자식을 다시 그리기 때문에 컴포넌트의 이전 모양이 지워지고 새로 변경된 크기나 위치에 그려짐

## 멀티태스킹
- 여러 개의 작업(태스크)이 동시에 처리되는 것

## 스레드와 운영체제
- 스레드(thread)
    - 운영체제에 의해 관리되는 하나의 작업 혹은 태스크
    - 스레드와 태스크(혹은 작업)은 바꾸어 사용해도 무관
- 멀티스레딩(multi-threading)
    - 여러 스레드를 실행시키는 응용프로그램을 작성하는 기법
- 스레드 구성
    - 작업을 실행하기 위해 작성한 프로그램 코드
    - 개발자가 작성
- 스레드 정보
    - 스레드 명, 스레드 ID, 스레드의 실행 요소 시간, 스레드의 우선 순위 등
    - 운영체제가 스레드에 대해 관리하는 정보

## 멀티태스킹과 멀티스레딩
- 멀티프로세싱(multi-processing)
    - 하나의 응용프로그램이 여러 개의 프로세스를 생성하고, 각 프로세스가 하나의 작업을 처리하는 기법
    - 각 프로세스 독립된 메모리 영역을 보유하고 실행
    - 프로세스 사이의 문맥 교환에 따른 과도한 오버헤드와 시간 소모의 문제점
- 멀티스레딩(multi-threading)
    - 하나의 응용프로그램이 여러 개의 스레드를 생성하고, 각 스레드가 하나의 작업을 처리하는 기법
    - 하나의 응용프로그램에 속한 스레드는 변수 메모리, 파일 오픈 테이블 등 자원으로 공유하므로, 문맥 교환에 따른 오버헤드가 매우 작음
    - 현재 대부분의 운영체제가 멀티스레딩을 기본으로 하고 있음

## 자바 스레드와 JVM
- 자바 스레드
    - 자바 가상 기계(JVM)에 의해 스케쥴되는 실행 단위의 코드 블럭
    - 스레드의 생명 주기는 JVM에 의해 관리됨 : JVM은 스레드 단위로 스케쥴링
- JVM과 자바의 멀티스레딩
    - 하나의 JVM은 하나의 자바 응용프로그램만 실행
        - 자바 응용프로그램이 시작될 때 JVM이 함께 실행됨
        - 자바 응용프로그램이 종료하면 JVM도 함께 종료함
    - 응용프로그램은 하나 이상의 스레드로 구성 가능
- 스레드 만드는 2가지 방법
    1. java.lang.Thread 클래스를 상속받아 스레드 작성
    2. java.lang.Runnable 인터페이스를 구현하여 스레드 작성

## main 스레드
- JVM이 응용프로그램을 실행할 때 디폴트로 생성되는 스레드
    - main() 메소드 실행 시작
    - main() 메소드가 종료하면 main 스레드 종료

## 스레드 동기화(Thread Synchronization)
- 멀티스레드 프로그램 작성시 주의점
    - 다수의 스레드가 공유 데이터에 동시에 접근하는 경우
        - 공유 데이터의 값에 예상치 못한 결과 발생 가능
- 스레드 동기화
    - 동기화란?
        - 스레드 사이의 실행순서 제어, 공유데이터에 대한 접근을 원활하게 하는 기법
    - 멀티스레드의 공유 데이터의 동시 접근 문제 해결
        - 방법 1) 공유 데이터를 접근하는 모든 스레드의 한 줄 세우기
        - 방법 2) 한 스레드가 공유 데이터에 대한 작업을 끝낼 때 까지 다른 스레드가 대기 하도록 함
- 자바의 스레드 동기화 방법 2가지
    - synchronized 키워드로 동기화 블록 지정
    - wait()-notify() 메소드로 스레드의 실행 순서 제어

## synchronized 블록 지정
- synchronized 키워드
    - 스레드가 독점적으로 실행해야 하는 부분(동기화 코드)을 표시하는 키워드
        - 임계 영역(criitical section) 표기 키워드
    - synchronized 블록 지정 방법
        - 메소드 전체 혹은 코드 블록
- synchronized 블록이 실행 될 때,
    - 먼저 실행한 스레드가 모니터 소유
        - 모니터란 해당 객체를 독점적으로 사용할 수 있는 권한
    - 모니터를 소유한 스레드가 모니터를 내놓을 때까지 다른 스레드 대기

## wait()-notify()를 이용한 스레드 동기화
- wait()-notify()가 필요한 경우
    - 공유 데이터로 두 개 이상의 스레드가 데이터를 주고 받을 때
        - producer-consumer문제
- 동기화 메소드
    - wait(): 다른 스레드가 notify()를 불러줄 때까지 기다린다.
    - notify(): wait()를 호출하여 대기중인 스레드를 깨운다.
        - wait(), notify()는 Object의 메소드
          
## TCP/IP 소개
- TCP/IP 프로토콜
    - 두 시스템 간에 데이터가 손상없이 안전하게 전송되도록 하는 통신 프로토콜
    - TCP에서 동작하는 응용프로그램 사례
        - e-mail,FTP,웹(HTTP)등

- TCP/IP 특징
    - 연결형 통신
        - 한 번 연결 후 계속 데이터 전송 가능
    - 보낸 순서대로 받아 응용프로그램에게 전달

## IP 주소
- 네트워크 상에서 유일하게 식별될 수 있는 컴퓨터 주소
    - 숫자로 구성된 주소
    - 4개의 숫자가 '.'으로 연결
        - ex) 192.156.11.15
- 숫자로 된 주소는 기억하기 어려우므로 www.naver.com과 같은 문자열로 구성된 도메인 이름으로 바꿔 사용
    - DNS(Domain Name System)
        - 문자열로 구성된 도메인 이름을 숫자로 구성된 IP 주소로 자동 변환
- 현재는 32비트의 IP 버전 4(IPv4)가 사용되고 있음
    - IP 주소 고갈로 인해 128비트의 IP버전 6(IPv6)이 점점 사용되는 추세
- 자신의 IP주소를 간단히 localhost라는 이름으로 사용 가능

## 포트
- 통신하는 프로그램 간에 가상의 연결단 포트 생성
    - IP주소는 네트워크 상의 컴퓨터 또는 시스템을 식별하는 주소
    - 포트 번호를 이용하여 통신할 응용프로그램 식별
- 모든 응용프로그램은 하나 이상의 포트 생성 가능
    - 포트를 이용하여 상대방 응용프로그램과 데이터 교환
- 잘 알려진 포트(well-know-ports)
    - 시스템이 사용하는 포트 번호
    - 잘 알려진 응용프로그램에서 사용하는 포트 번호
        - 0부터 1023 사이의 포트 번호
        - ex) SSH 22, HTTP 80, FTP 21
    - 잘 알려진 포트 번호는 개발자가 사용하지 않는 것이 좋음
        - 충돌 가능성이 있음

## 소켓 
- TCP/IP 네트워크를 이용하여 쉽게 통신 프로그램을 작성하도록 지원 하는 기반 기술
- 소켓
    - 두 응용프로그램 간의 양방향 통신 링크의 한쪽 끝 단
    - 소켓끼리 데이터를 주고 받음
    - 소켓은 특정 IP 포트 번호와 결합
- 자바로 소켓 동신할 수 있는 라이브러리 지원
- 소켓 종류 : 서버 소켓과 클라이언트 소켓

## Socket 클래스, 클라이언트 소켓
- Socket 클래스
    - 클라이언트 소켓에 사용되는 클래스
    - java.net 패키지에 포함
    - 생성자
        - Socket()
        - Socket(InetAddress address, int port)
        - Socket(String host, int port)

## 클라이언트에서 소켓으로 서버에 접속하는 코드
- 클라이언트 소켓 생성 및 서버에 접속
    - Socket의 생성자에서 128.12.1.1의 주소의 9999포트에 접속
- 소켓으로부터 데이터를 전송할 입출력 스트림 생성
    - BufferedReader in = new BufferedReader(
    new InputStreamReader(clientSocket.getInputStream()));
    -  BufferedWriter out = new BufferedWriter(
    new OutputStreamWriter(clientSocket.getOutputStream()));
- 서버로 데이터 전송
    - flush()를 호출하면 스트림 속에 데이터 모두 전송
        - out.write("hello"+"\n");
        out.flush();
- 서버로부터 데이터 수신
    -  String line = in.readline(); 
    //서버로부터 한행의문자열수신   
- 네트워크 접속 종료
    - clientSocket.close();

## 서버에 클라이언트가 연결되는 과정
- 서버는 서버 소켓으로 들어오는 연결 요청을 기다림(listen)
- 클라이언트가 서버에게 연결 요청
- 서버가 연결 요청 수락(accept)
    - 새로운 클라이언트 소켓을 만들어 클라이언트와 통신하게 함
    - 그리고 다시 다른 클라이언트의 연결을 기다림
- 서버 소켓 생성
    - ServerSocket serverSocket = new ServerSocket(9999);
        - 서버는 9999포트에 접속 기다리는 포트로 9999선택
- 클라이언트로부터 접속 기다림
    - Socket socket = serverSocket.accept();
        - accept() 메소드는 접속 요청이 오면 접속 후 새 Socket 객체 반환
        - 접속 후 새로 만들어진 Socket 객체를 통해 클라이언트와 통신
- 네트워크 입출력 스트림 생성   
    - BufferedReader in = new BufferedReader(
    new InputStreamReader(socket.getInputStream()));
    -  BufferedWriter out = new BufferedWriter(
    new OutputStreamWriter(socket.getOutputStream()));

## 서버-클라이언트 채팅 프로그램 만들기
- 간단한 채팅 프로그램
    - 서버와 클라이언트가 1:1로 채팅
    - 클라이언트와 서버가 서로 한번씩 번갈아 가면서 문자열 전송
        - 문자열 끝에 "\n"을 덧붙여 보내고 라인 단위로 수신
    - 클라이언트가 bye를 보내면 프로그램 종료
    
        




    ColorPoint cp = new ColorPoint(); // 서브 클래스 객체 생성



