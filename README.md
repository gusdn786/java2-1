# 강현호 <h1>202130202

## 3월 15일 Java2 강의
깃 허브 주소를 복사하여 vscode에 붙여넣은뒤 깃 허브를 활용하는 방법에 대해 배웠다.
source control에 내용을 넣은 뒤 commit을 누른 뒤 업로드를 하면 깃 허브에 업로드가 된다.
java 개발 환경 구축
openJDK 설치, Eclips 설치, Eclips에 openJDK 연결
자바 프로젝트 생성

## 3월 22일 Java2 강의
자바 프로젝트, 클래스 생성 후 소스 편집, 컴파일 및 실행
자바 응용프로그램의 종류
- 데스크톱 응용프로그램
- 자바 서블릿 응용프로그램
- 모바일 응용프로그램

Java 특징
플랫폼 독립성, 객체 지향, 클래스로 캡슐화, 소스와 클래스파일, 실행 코드 배포, 패키지, 멀티스레드, 가비지 컬렉션,
프로그램 작성이 쉽다, 실행 속도를 개선하기 위해 JIT 컴파일러가 사용된다.

자바 프로그램의 구조
- 클래스 만들기
- 주석문
- main() 메소드
- 메소드, 메소드 호출
- 변수 선언
- 문장
- 화면 출력

식별자: 클래스, 변수, 상수, 메소드에 붙이는 이름(identifier)
식별자 이름 규칙에서 식별자를 만들 때 규칙을 준수 해야 함.
1. 식별자로 한글을 사용하면 안됨.
2. 길이 제한이 없음.
3. 대소문자 구별.

## 3월 29일 java2 강의
타입 변환이란 변수나 상수 혹은 리터럴을 다른 타입을 변환하는것을 말한다.
- 자동타입 변환: 치환문이나 수식 내에서 타입이 일치하지 않을때 컴파일러는 작은 타입을 큰 타입으로 자동변환
- 강제타입 변환(캐스팅) : 큰 타입을 작은 타입으로 변환해야 할때 자동 변환 대신 컴파일 오류 발생 손실이 발생한다는 사실을 알고 변환한다면 강제로()안에 타입을 지정

자바의 키 입력
- System.in
표준 입력 스트림 객체로, 키 값을 바이트 정보로 바꾸어 제공하는 저수준 스트림 객체

Scanner을 이용한 키 입력 
- scanner 객체는 다음과 같이 생성한다.
"scanner scanner - new scanner(system.in);"
- Scanner을 사용하기 위해서는 프로그램의 맨 앞줄에 "import" 문이 필요하다.
"import java.util.Scanner;"
import문은 scanner 클래스의 경로명이 java.utill.scanner임을 알려준다

예제 2-5 연습

식과 연산자
- 주어진 식을 계산하여 결과를 얻어내는 과정을 연산이라고 한다

산술연산
- 수직 계산에 사용하는 산술 연산자는 더하기,빼기, 곱하기, 나누기, 나머지(%)의 5갸더 /는 몫을 구하여, %는 나머지를 구한다

예제 2-6 연습

증강연산
-  ++,-- 피연산자의 앞 또는 뒤에 붙어 값을 1 증가시키거나 1 감소시킨다.
a++ a를 1 증가하고 증가전의 값 변환
++a a를 1증가하고 증가된 값 변환
a-- a를 1 가모하고 감소 전의 값 변환
--a a를 1 감소하고 감소된 값 변환

대입 연산 
- 연산자의 오른쪽 식의 결과를 왼쪽에 있는 변수에 대입

비교연산, 논리 연산
- 비교연산자는 두 개의 피연산자를 비교하여 true 또는 false의 논리 결과를 내는 연산자
- 논리 연산자는 논리 값을 대상으로 AND,OR,XOR,NOT의 논리 연산을 하여 논리 값을 내는 연산자

조건문
- 단순 IF문 조건식은 비교 연산이나 논리 연산의 혼합된 식으로 구성되며 결과는 불린 값이다.
- 조건식이 참이면 if 내부의 실행 문장이 실행되며 거짓이면 if문을 벗어난다
- 다중 if-else 문은 if의 '조건식'이 참인 경우와 거짓인 경우에 실행할 문장을 각각 지시한다

## 4월 05일 java2 강의
2차원 배열
- 2차원 배열의 선언과 생성
1차원 배열과 마찬가지로 2차원 배열에서도 레퍼런스 변수 선언 후 배열을 생성하며, 2차원 배열의 레퍼런스 변수를 선언
int inArray[][]; 또는 int [][] intArray; // 2차원 배열의 레퍼런스 변수 선언
intArray = new int[2][5]; // 2행 5열(2*5)의 2차원 배열 생성

2차원 배열의 초기화
- 2차원 배열을 선언할 때 각 원소를 초기화 할 수 있다. 자동으로 초기화된 배열이 생성된다.
int inArray[][] = { {0,1,2}, {3,4,5}, {6,7,8} }; // 3*3 배열 생성
char charArray[][] = { {'a','b','c'}, {'d','e','f'} }; // 2*3 배열 생성
double doubleArray[][] = { {0.01,0.02}, {0.03,0.04} }; // 2*2 배열 생성

자바의 예외 처리
예외한 실행 중 오동작이나 결과에 악영향을 미치는 예상치 못한 상황 발생을 예외라고 한다.
- 예외 발생 사례
정수를 0으로 나누는 경우
배열의 크기보다 큰 인덱스로 배열의 원소를 접근하는 경우
정수를 읽는 코드가 실행되고 있을 때 사용자가 문자를 입력한 경우

자바의 예외 처리,try-catch-finally 문
예외 처리란 발생한 예외에 대해 개발자가 작성한 프로그램 내에서 대응하는 것을 말한다. 자바는 예외 처리시 try,catch,finally문을 사용
try {
    예외가 발생할 가능성이 있는 실행문(try 블록)
}
catch (처리할 예외 타입 선언){
    예외 처리문(catch 블록)
}
finally {
    예외 발생 여부와 상관없이 무조건 실행되는 문장(finally 블록)
}

예외가 발생할 가능성이 있는 실행문들을 try{} 블록으로 묶고, 예외 처리 코드는 catch{} 블록에 작성한다.
catch() 문의 () 안에는 처리하고자 하는 예외의 타입을 선언한다. catch {} 블록은 예외마다 하나씩 작성되어야 한다.
finally {}는 선택적 구문으로서 생략해도 상관없으며 실제 많은 경우 생략된다.
finally 블록이 존재하는 경우, try 블록 실행 후 finally 블록이 순차적으로 실행되며, try 블록이 실행되는 도중 예외가 발생하였다면 catch 블록 실행 후 finally 블록을 실행한다. 그리고 finally 블록 아래의 코드를 계속 실행한다.

객체 지향 언어의 목적
- 소프트웨어의 생산성 향상
1. 컴퓨터 산업 발전에 따라 소프트웨어의 생명 주기(life cycle) 단축
2. 객체 지향 언어

- 실세계에 대한 쉬운 모델링
1. 초기 프로그래밍
2. 현대 프로그래밍
3. 객체 지향 언어
   
## 4월 12일 java2 강의
static 멤버 
- 클래스의 멤버들 중 다음과 같이 static 지시어로 선언된 멤버를 
static 멤버라고 부른다
- static으로 선언된 멤버는 non-static 멤버와 매우 다른 특성을 가진다
- static 멤버는 클래스당 하나만 생성되는 멤버로서, 동일한 클래스의 
모든 객체들이 공유하므로 클래스 멤버라고 부른다
- non-static 멤버는 객체가 생길때 함께 생성되고 객체가 사라지면 함께 사라진다 그러나 static 멤버는 프로그램을 시작할 때나 클래스 로딩 시에 생성된다
- 객체를 생성하기 전에도 static 멤버는 사용
-  생성된 객체가 소멸된 후에도 static 멤버는 여전히 살아 공간을 차지하고 있으며 프로그램이 종료할 때 함께 소멸

static 멤버 사용
non-static 멤버가 객체 이름으로만 활용 할 수 있는 것과는 달리
static멤버는 객체 이름이나 클래스 이름으로 모두 활용 가능하다.
   staticsample.m =3; // 클래스 이름으로 static필드 접근
   staticsample.f(); // 클래스 이름으로 static 메소드 호출

static 메소드의 제약 조건
static 메소드는 두 개의 제약 사항을 가진다

- static 메소드는 오직 static 멤버만 접근 할 수 있다.
static 메소드는 객체가 생성디지 않은 상황에서도 사용이 가능하므로
객체에 속한 인스턴스 메소드, 인스턴스 변수 등을 사용할 수 없고
static 멤버들만 사용 가능하다.
인스턴스 메소드는 static멤버들을 사용할 수 있다.

- static 메소드에서는 this를 사용할 수없다
static메소드는 객체 없이도 존재하기 때문에, static 메소드에서 
this를 사용할 수 없다.

final 클래스
final 클래스 이름 앞에  사용되면 클래스를 상속받을 수 없음을 지정한다.

final 메소드
메소드 앞에 final이 붙으면 이 메소드는 더 이상 오버라이딩 할 수 없음을 지저한다
자식 클래스가 부모 클래스의 특정 메소드를 오버라이딩 하지 못하게 하고 
무조건 상속받아 사용하도록 하고자 한다면 final로 지정하면 된다.

final 필드 
자바에서 final로 필드를 선언하면 필드는 상수가 된다.
상수 필드는 한번 초기화 되면 값을 변경할수없다.
final 키워드를 public static와 함께 선언하면 프로그램 전체에서 공유할 수 있는
상수가된다

자바 상속의 특징
- 클래스 다중 상속(multiple ingeritance) 불허
C++는 다중 상속 가능(C++는 다중 상속으로 멤버가 중복 생성되는 문제 있음)
자바는 인터페이스(interface)의 다중 상속 허용
- 모든 자바 클래스는 묵시적으로 Object클래스 상속 받음
java.iang.Object는 클래스는 모든 클래스의 슈퍼 클래스

슈퍼 클래스의 멤버에 대한 서브 클래스의 접근
- 슈퍼 클래스의 private 멤버
서브 클래스에서 접근할 수 없음
-슈퍼 클래스의 디폴트 멤버
서브 클래스가 동일한 패키지에 있을 때, 접근 가능
- 서브 클래스의 public 멤버
서브 클래스는 항상 접근 가능
- 서브 클래스의  protected 멤버
같은 패키지 내의 모든 클래스 접근 허용
패키지 여부와 상관없이 서브 클래스는 접근 가능

protected 멤버
- proctected 멤버에 대한 접근
같은 패키지의 모든 클래스에게 허용
상속되는 서브 클래스(같은 패키지든 다른 패키지든 상관 없음)에게 허용

서브 클래스/슈퍼 클래스의 생성사 호줄과 실행
- 서브 클래스의 객체가 생성될 때
슈퍼 클래스 생성자와 서브 클래스 생성자 모두 실행
호출 순서
- 서브 클래스의 생성자 먼저 호출
-서브 클래스의 생성자는 실행 전 슈퍼 클래스 생성자 호출
실행 순서
- 슈퍼 클래스의 생성자가 먼저 실행된 후 서브 클래스의 생성자 실행

서브 클래스와 슈퍼 클래스의 생성자 선택
- 슈퍼 클래스와 서브 클래스
각각 여러 개의 생성자 작성 가능
- 서브 클래스의 객체가 생성될 때
슈퍼 클래스 생성자 1개와 서브 클래스 생성자 1개가 실행
- 서브 클래스의 생성자와 슈퍼 클래스의 생성자가 결정되는 방식
1. 개발자의 명시적 선택
 - 서브 클래스 개발자가 슈퍼 클래스의 생성자 명시적 선택
 - super() 키워드를 이용하여 선택
2. 컴파일러가 기본생성자 선택
 - 서브 클래스 개발자가 슈퍼 클래스의 생성자를 선택하지 않는 경우
 - 컴파일러가 자동으로 슈퍼 클래스의 기본 생성자 선택

 상속의 장점
 - 클래스 사이의 멤버 중복 선언 불필요 - 클래스의 간결화
 - 클래스들의 계층적 분류로 클래스 관리 용어
 - 클래스 재사용과 확장을 통한 소프트웨어의 생산성 향상

 클래스 상속과 객체
 - 상속 선언
 extends 키워드로 선언 (부모 클래스를 물려받아 확장한다는 의미)
 부모 클래스 -> 슈퍼 클래스(super class)
 자식 클래스 -> 서브 클래스(sub class)

 서브 클래스 객체의 모양
 - 슈퍼 클래스 객체와 서브 클래스의 객체는 별개
 - 서브 클래스 개게는 슈퍼 클래스 멤버 포함

 서브 클래스 객체 생성
 Point 클래스의 객체 p와 Colorpoint 클래스의 객체 cp는 다음가 같이 생성한다
    Point p = new Point();
    ColorPoint cp = new ColorPoint(); // 서브 클래스 객체 생성
자바 상속의 특징
- 클래스 다중 상속(multiple ingeritance) 불허
C++는 다중 상속 가능(C++는 다중 상속으로 멤버가 중복 생성되는 문제 있음)
자바는 인터페이스(interface)의 다중 상속 허용
- 모든 자바 클래스는 묵시적으로 Object클래스 상속 받음
java.iang.Object는 클래스는 모든 클래스의 슈퍼 클래스

슈퍼 클래스의 멤버에 대한 서브 클래스의 접근
- 슈퍼 클래스의 private 멤버
서브 클래스에서 접근할 수 없음
-슈퍼 클래스의 디폴트 멤버
서브 클래스가 동일한 패키지에 있을 때, 접근 가능
- 서브 클래스의 public 멤버
서브 클래스는 항상 접근 가능
- 서브 클래스의  protected 멤버
같은 패키지 내의 모든 클래스 접근 허용
패키지 여부와 상관없이 서브 클래스는 접근 가능

protected 멤버
- proctected 멤버에 대한 접근
같은 패키지의 모든 클래스에게 허용
상속되는 서브 클래스(같은 패키지든 다른 패키지든 상관 없음)에게 허용

서브 클래스/슈퍼 클래스의 생성사 호줄과 실행
- 서브 클래스의 객체가 생성될 때
슈퍼 클래스 생성자와 서브 클래스 생성자 모두 실행
호출 순서
- 서브 클래스의 생성자 먼저 호출
-서브 클래스의 생성자는 실행 전 슈퍼 클래스 생성자 호출
실행 순서
- 슈퍼 클래스의 생성자가 먼저 실행된 후 서브 클래스의 생성자 실행

서브 클래스와 슈퍼 클래스의 생성자 선택
- 슈퍼 클래스와 서브 클래스
각각 여러 개의 생성자 작성 가능
- 서브 클래스의 객체가 생성될 때
슈퍼 클래스 생성자 1개와 서브 클래스 생성자 1개가 실행
- 서브 클래스의 생성자와 슈퍼 클래스의 생성자가 결정되는 방식
1. 개발자의 명시적 선택
 - 서브 클래스 개발자가 슈퍼 클래스의 생성자 명시적 선택
 - super() 키워드를 이용하여 선택
2. 컴파일러가 기본생성자 선택
 - 서브 클래스 개발자가 슈퍼 클래스의 생성자를 선택하지 않는 경우
 - 컴파일러가 자동으로 슈퍼 클래스의 기본 생성자 선택

 상속의 장점
 - 클래스 사이의 멤버 중복 선언 불필요 - 클래스의 간결화
 - 클래스들의 계층적 분류로 클래스 관리 용어
 - 클래스 재사용과 확장을 통한 소프트웨어의 생산성 향상

 클래스 상속과 객체
 - 상속 선언
 extends 키워드로 선언 (부모 클래스를 물려받아 확장한다는 의미)
 부모 클래스 -> 슈퍼 클래스(super class)
 자식 클래스 -> 서브 클래스(sub class)

 서브 클래스 객체의 모양
 - 슈퍼 클래스 객체와 서브 클래스의 객체는 별개
 - 서브 클래스 개게는 슈퍼 클래스 멤버 포함

 서브 클래스 객체 생성
 Point 클래스의 객체 p와 Colorpoint 클래스의 객체 cp는 다음가 같이 생성한다
    Point p = new Point();

## 5월 3일 java2 강의
컬렉션
- 요소 라고 불리는 가변 개수의 객체들의 저장소
- 고정 크기의 배열을 다루는 어려움 해소

## 컬렉션의 특징
1. 컬렉션은 제네릭(generics)기법으로 구현
- 컬렉션 클래스나 인터페이스의 이름에는 <E>,<K>,<V> 등이 항상 포함된다. 이들은 "타입 매개 변수" 라고 하며, 컬렉션 요소<element>를 '일반화'시킨 타입이다. 
그러므로 Vector<E>에서 E 대신 Integer나 String으로 구체적인 타입을 지정하여 사용한다
2. 컬렉션의 요소는 객체들만 가능하다.
- int,char,double 등의 기본 타입의 데이터는 기본적으로 컬렉션의 요소로 불가능하다.

## 제네릭의 기본 개념
- 제네릭은 메소드나 클래스 코드를 찍어내듯이 생산할 수 있도록 일반화(generic)시키는 도구이다.

## 제네릭 타입 매개 변수
- E : Element 를 의미하며 컬렉션에서 요소를 표시할 때 사용
- T : Type을 의미
- V : Value를 의미
- K : key를 의미

## 벡터 Vector<E>의 특징
- <E>에 사용할 요소의 특정 타입으로 구체화
- 배열을 가변 크기로 다룰 수 있게 하는 컨테이너
1. 배열의 길이 제한 극복
2. 요소의 개수가 넘치면 자동으로 길이 조절
- 요소 객체들을 삽입,삭제,검색하는 컨테이너
1. 삽입,삭제에 따라 자동으로 요소의 위치 조정
- Vector에 삽입 가능한 것
1. 객체,null
2. 기본 타입의 값은 Wrapper객체로 만들어 저장
- Vector에 객체 삽입
1. 벡터의 맨 뒤, 중간에 객체 삽입 가능
- Vector에서 객체 삭제
1. 임의의 위치에 있는 객체 삭제 가능

## ArrayList<E>
- 가변 크기 배열을 구현한 클래스
1. <E>에 요소로 사용할 특정 타입으로 구체화
- 벡터와 거의 동일
1. 요소 삽입, 삭제, 검색 등 벡터 기능과 거의 동일
2. 벡터와 달리 스레드 동기화 기능 없음

## 컬렉션의 순차 검색을 위한 Iterator
- Iterator<E> 인터페이스
    - 리스트 구조의 컬렉션에서 요소의 순차 검색을 위한 인터페이스
    - Vector<E>, ArrayList<E>, LinkedList<E>가 상속받는 인터페이스
- Iterator 객체 얻어내기
    - 컬렉션의 iterator() 메소드 호출
    - 해당 컬렉션을 순차 검색할 수 있는 Iterator 객체 리턴

## HashMap<K,V>
- 키(Key)와 값(Value)의 쌍으로 구성되는 요소를 다루는 컬렉션
    - K : 키로 사용할 요소의 타입
    - V : 값으로 사용할 요소의 타입
    - 키와 값이 한쌍으로 삽입
    - '값'을 검색하기 위해서는 반드시 '키' 이용    
- 삽입 및 검색이 빠른 특징
    - 요소 삽입 : put()메소드
    - 요소 검색 : get()메소드

 ## 자바의 GUI(Graphical User Interface) 
GUI 응용 프로그램
- GUI
    - 사용자가 편리하게 입출력 할 수 있도록 그래픽으로 화면을 구성하고, 마우스나 키보드로 입력 받을 수 있도록 지원하는 사용자 인터페이스
- 자바 언어에서 GUI 응용프로그램 작성
    - AWT와 Swing 패키지에 강력한 GUI 컴포넌트 제공
    - 쉬운 GUI 프로그래밍

AWT와 Swing 패키지
- AWT(Abstract Windowing Toolkit) 패키지
    - 자바가 처음 나왔을 때부터 배포된 GUI패키지, 최근에는 거의 사용하지 않음
    - AWT 컴포넌트는 중량 컴포넌트(heavy weight component)
- Swing 패키지
    - AWT 기술을 기반으로 작성된 자바 라이브러리
    - 모든 AWT 기능 + 추가된 풍부하고 화려한 고급 컴포넌트
    - AWT 컴포넌트를 모두 스윙으로 재작성. AWT 컴포넌트 이름 앞에 J를 덧붙임
    - 순수 자바 언어로 구현
    - 스윙 컴포넌트는 경량 컴포넌트(light weight component)
    - 현재 자바의 GUI로 사용됨 

## 컨테이너와 컴포넌트
컨테이너
- 다른 컴포넌트를 포함할 수 있는 GUI 컴포넌트
    - java.awt.Container를 상속받음
- 다른 컨테이너에 포함될 수 있음
    - AWT 컨테이너 : Panel,Frame,Applet,Dialog,Window
    - Swing 컨테이너 : JPanel,JFrame,JApplet,Jdialog,JWindow

컴포넌트
- 컨테이너에 포함되어야 화면에 출력될 수 있는 GUI 객체
- 다른 컴포넌트를 포함할 수 없는 순수 컴포넌트
- 모든 GUI 컴포넌트가 상속받는 클래스 : java.awt.Component
- 스윙 컴포넌트가 상속받는 클래스 : javax.swing.JComponent

최상위 컨테이너
- 다른 컨테이너에 포함되지 않고도 화면에 출력되며 독립적으로 존재 가능한 컨테이너
    - 스스로 화면에 자신을 출력하는 컨테이너 : JFrame,JDialog,JApplet

## 스윙 GUI 프로그램 만들기
- 스윙 GUI 프로그램을 만드는 과정
1. 스윙 프레임 만들기
2. main() 메소드 작성
3. 스윙 프레임에 스윙 컴포넌트 붙이기

- 스윙 프로그램 작성에 필요한 import문
    - import java.awt.*; //그래픽 처리를 위한 클래스들의 경로명
    - import java.awt.event.*; // AWT 이벤트 사용을 위한 경로명
    - import javax.swing.*; // 스윙 컴포넌트 클래스들의 경로명
    - import.javax.swing.event.*; // 스윙 이벤트를 위한 경로명

## 스윙 프레임
- 스윙 프레임 : 모든 스윙 컴포넌트를 담는 최상위 컨테이너
    - JFrame을 상속받아 구현
    - 컴포넌트들은 화면에 보이려면 스윙 프레임에 부착되어야함
- 스윙 프레임(JFrame) 기본 구성
    - 프레임 - 스윙 프로그램의 기본 틀
    - 메뉴바 - 메뉴들이 부착되는 공간
    - 컨텐트팬 - GUI 컴포넌트들이 부착되는 공간

## 프레임 만들기 ,JFrame 클래스 상속
- 스윙 프레임
    - JFrame 클래스를 상속받은 클래스 작성
    - 프레임의 크기 반드시 지정 : setSize() 호출
    - 프레임을 화면에 출력하는 코드 반드시 필요 : setVisible(true) 호출

## 스윙 응용프로그램에서 main()의 기능과 위치
- 스윙 응용프로그램에서 main()의 기능 최소화 바람자기
    - 스윙 응용프로그램이 실행되는 시작점으로서의 기능만
    - 스윙 프레임을 생성하는 정도의 코드로 최소화
public static void main(String [] args) {
    MyFrame frame = new MyFrame(); // 스윙 프레임 생성
}

## 프레임에 컴포넌트 붙이기
- 타이틀 달기
    - super() 나 setTitle() 이용
- 컨텐트팬에 컴포넌트 달기
- 컨텐트팬이란?
    - 스윙 컴포넌트들이 부착되는 공간
- 컨텐트팬 알아내기
    - 스윙 프레임에 붙은 디폴트 컨텐트팬 알아내기
- 컨텐트팬에 컴포넌트 붙이기
- 컨텐트팬 변경

    ColorPoint cp = new ColorPoint(); // 서브 클래스 객체 생성



